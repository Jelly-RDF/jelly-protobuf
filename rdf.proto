syntax = "proto3";
package pl.ostrzyciel.jelly.core.proto;

// Protocol Buffers Rdf serialization.

// === Rdf Terms ===
message RdfIri {
  // Either of these can be zero if the prefix or the suffix are not used.
  uint32 prefix_id = 1;
  uint32 name_id = 2;
}

message RdfBnode {
  string label = 1;
}

message RdfDatatype {
  uint32 dt_id = 1;
}

message RdfLiteral {
  string lex = 1;
  oneof literalKind {
    bool simple = 2;
    string langtag = 3;
    RdfDatatype datatype = 4;
  }
}

message RdfRepeat {
}

message RdfTerm {
  oneof term {
    RdfIri        iri = 1;
    RdfBnode      bnode = 2;
    RdfLiteral    literal = 3;
    RdfTriple     triple_term = 4;
    RdfRepeat     repeat = 5;
  }
}

// === Triples and quads ===
message RdfTriple {
  RdfTerm s = 1;
  RdfTerm p = 2;
  RdfTerm o = 3;
}

message RdfQuad {
  RdfTerm s = 1;
  RdfTerm p = 2;
  RdfTerm o = 3;
  RdfTerm g = 4;
}

// === Lookup tables ===

message RdfNameEntry {
  // 1-based
  uint32 id = 1;
  string value = 2;
}

message RdfPrefixEntry {
  // 1-based
  uint32 id = 1;
  string value = 2;
}

message RdfDatatypeEntry {
  // 1-based
  uint32 id = 1;
  string value = 2;
}

message RdfStreamOptions {
  uint32 max_name_table_size = 1;
  uint32 max_prefix_table_size = 2;
  uint32 max_datatype_table_size = 3;
  bool use_repeat = 4;
}

// === Streams ===
message RdfStreamRow {
  oneof row {
    RdfTriple triple = 1;
    RdfQuad quad = 2;
    RdfNameEntry name = 3;
    RdfPrefixEntry prefix = 4;
    RdfDatatypeEntry datatype = 5;
    RdfStreamOptions options = 6;
  }
}

message RdfStreamFrame {
  repeated RdfStreamRow rows = 1;
}
